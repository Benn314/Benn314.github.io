<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>重拾 C++</title>
    <url>/2023/12/13/%E9%87%8D%E6%8B%BEC++/</url>
    <content><![CDATA[<hr>
<p>参加蓝桥杯和天梯杯比赛时，使用 C++ 刷题的一些随笔</p>
<span id="more"></span>

<p><a href="https://www.liuchuo.net/archives/6565">如何在Dev-Cpp中使用C++11中的函数：stoi、to_string、unordered_map、unordered_set、auto</a></p>
<h2 id="算法常用API："><a href="#算法常用API：" class="headerlink" title="算法常用API："></a>算法常用API：</h2><p>stoi</p>
<p>to_string <em>用于 int to string</em></p>
<p>unordered_map</p>
<p>unordered_set</p>
<p>auto</p>
<p>​    </p>
<blockquote>
<p>vector打印的字符会变成ASCII值</p>
</blockquote>
<p>​    </p>
<h2 id="VS-2022-快捷键"><a href="#VS-2022-快捷键" class="headerlink" title="VS 2022 快捷键"></a>VS 2022 快捷键</h2><ul>
<li><strong>Ctrl+D</strong>：快速复制当前行到下一行</li>
<li><strong>Alt + ↑/↓</strong>：移动当前行</li>
<li><strong>Ctrl+K+C</strong>：注释</li>
<li><strong>Ctrl+K+U</strong>：取消注释</li>
</ul>
<p>​    </p>
<h2 id="printVector"><a href="#printVector" class="headerlink" title="printVector"></a>printVector</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">	<span class="comment">//尾插</span></span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="number">50</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="string">&#x27;I&#x27;</span>);</span><br><span class="line">	v1.<span class="built_in">push_back</span>(<span class="string">&#x27;II&#x27;</span>);</span><br><span class="line">	<span class="built_in">printVector</span>(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test01</span>(); <span class="comment">// 10 20 30 40 50 97 73 18761</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="getline-cin-str"><a href="#getline-cin-str" class="headerlink" title="getline(cin,str)"></a>getline(cin,str)</h2><p>使用getline(cin,str) 获取单变量的输入字符，范围是一行（即忽视空格），该函数需要引入头文件#include <code>&lt;string&gt;</code></p>
<p>‘\0’ 在c++中也是NULL的意思，即回车后，获取的字符就是‘\0’ ,也就是‘NULL’ 常用于条件判断</p>
<p>天梯比赛中：一次输入便一次输出是可以的，不是说要等到全部输入完成才进行输出</p>
<p>很巧妙的一个比赛技巧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; i++) &#123;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">find</span>(str) == s.<span class="built_in">end</span>() &amp;&amp; ans.<span class="built_in">find</span>(str) == ans.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; str;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置flag来控制 “ “ 达到末尾没有空格的目的</p>
<p>set<strong>不允许</strong>容器中有<strong>重复</strong>的元素</p>
<p>​    </p>
<h2 id="存放元素"><a href="#存放元素" class="headerlink" title="存放元素"></a>存放元素</h2><p>set主用 <code>insert()</code>，vector主用 <code>push_back()</code></p>
<p>​    </p>
<h2 id="set-find"><a href="#set-find" class="headerlink" title="set-find()"></a>set-find()</h2><p><code>find(key);</code>  // 查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</p>
<blockquote>
<p>查找   —  find    （返回的是迭代器）</p>
</blockquote>
<p>​    </p>
<h2 id="字符串大小写转换-cpp"><a href="#字符串大小写转换-cpp" class="headerlink" title="字符串大小写转换.cpp"></a>字符串大小写转换.cpp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化方法2：利用 toupper() 和 tolower() 函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConversionofLetterTwo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">		ch = <span class="built_in">toupper</span>(ch);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">		ch = <span class="built_in">tolower</span>(ch);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Invaild Word\n&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">ConversionofLetterTwo</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="字符串反转"><a href="#字符串反转" class="headerlink" title="字符串反转"></a>字符串反转</h2><p>使用 <code>algorithm</code> 中的 <code>reverse</code> 函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    string s = <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());  </span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>vector容器也适用，也是写成 <code>reverse(s.begin(),s.end()); </code></p>
<p><strong>不定长数组用 vector</strong></p>
<p>​    </p>
<h2 id="vector是不定长数组，能用-访问元素"><a href="#vector是不定长数组，能用-访问元素" class="headerlink" title="vector是不定长数组，能用[]访问元素"></a>vector是不定长数组，能用[]访问元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测vector能否用[]访问元素</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v1[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v1[<span class="number">9</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：可以，插入进去就是数组，而且是不定长数组，可以通过[]访问数组元素</p>
</blockquote>
<p>长度：数组用length()，容器用size()</p>
<p>用临时数组来进行条件判断很好用 不要总想着在目的数组上进行数组改动 可以通过临时数组的改动 最后赋值给目的数组</p>
<p>string库函数，<code>append()</code> 用于在字符串后面进行追加字符串操作</p>
<p>​    </p>
<h2 id="字符串的替换replace"><a href="#字符串的替换replace" class="headerlink" title="字符串的替换replace()"></a>字符串的替换replace()</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//替换</span></span><br><span class="line">	string str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">	str1.<span class="built_in">replace</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">test02</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="【问题】cin-getline-混合使用时不能输入-直接执行下一行"><a href="#【问题】cin-getline-混合使用时不能输入-直接执行下一行" class="headerlink" title="【问题】cin getline 混合使用时不能输入 直接执行下一行"></a>【问题】cin getline 混合使用时不能输入 直接执行下一行</h2><p>经常会遇到一个问题，就是需要混合使用cin&gt;&gt;, cin.getline(), getline()时，有时会碰到不等你输入，就直接运行下一行的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	string c;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">getline</span>(cin, s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是因为缓冲区还剩一个回车符 直接赋给了getline() 然后就输入执行结束 实际上getline的字符你还没有输入 所以看到这种情况懵了</p>
<blockquote>
<p>先cin&gt;&gt;，再getline()的情况，是因为cin&gt;&gt;会在缓冲区中多出一个回车符，即你输入完之后，敲完回车符之后，cin&gt;&gt;会在缓冲区中再多保留一个回车符，这个多出来的回车符就导致下面getline()执行时，自动读取缓冲区内的回车符，于是这句getline()就相当于你什么都没有敲就执行完了，自然就会去执行下面的语句了。</p>
<p>这种情况的解决方法很简单，在cin&gt;&gt;后面加一句cin.get()就行了，这个cin.get()就会将缓冲区内多出来的回车符消耗掉，于是后面的输入就正常了</p>
</blockquote>
<p>修改过后的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> N;</span><br><span class="line">	string c;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	cin &gt;&gt; c;</span><br><span class="line">	cin.<span class="built_in">get</span>(); <span class="comment">// 用 getchar();也行</span></span><br><span class="line">	<span class="comment">//getchar(); //如果是char c的话</span></span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">getline</span>(cin, s);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="sort-Algorithm"><a href="#sort-Algorithm" class="headerlink" title="sort() - Algorithm"></a>sort() - Algorithm</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：定义比较函数（最常用）</span></span><br><span class="line"><span class="comment">//情况一：数组排列</span></span><br><span class="line"><span class="type">int</span> A[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp1</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//int为数组数据类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;<span class="comment">//降序排列</span></span><br><span class="line"><span class="comment">//return a&lt;b;//默认的升序排列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(A,A+<span class="number">100</span>,cmp1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参考文章：https://www.cnblogs.com/stones-dream/p/10183210.html</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="常犯的一个错误：段错误"><a href="#常犯的一个错误：段错误" class="headerlink" title="常犯的一个错误：段错误"></a>常犯的一个错误：段错误</h2><p>经常原因：for循环从最大长度到0 经常只改了第一条件，第三条件 i++ 总是忘记改成 i–</p>
]]></content>
  </entry>
  <entry>
    <title>解决Hexo本地相对路径引用不生效的问题</title>
    <url>/2023/12/13/%E8%A7%A3%E5%86%B3Hexo%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一年前搭建了此博客，由于本地仓库图片相对路径与线上环境图片引用地址不符导致线上图片无法正常显示，同时写博客文章需要耗费较多时间来进行内容验证和排版，故而废弃了博客，今天重新给它捡回来。</p>
<span id="more"></span>

<p>Hexo发布的文章被存放正在 <code>/source/_post</code> 中，这里我们以文章 <code>aaa</code> 为例，对应到线上环境的 url 地址变成了  <code>https://你的github用户名.github.io/year/month/day/aaa</code>，所以线上部署的图片如果想要正常显示，需要将其存放在该 url 地址的后面，因为最终被渲染后，是放在同一个文件夹下的，也就是 <code>https://你的github用户名.github.io/year/month/day/aaa/你的图片资源名</code> 但 Hexo 官方并没有对该情况做出合适的解决方案，只有一个原生方案是将你的静态资源放到 <code>public/image</code> 目录中进行统一管理，在部署阶段会将本地相对路径进行重定向，而这如果在博客文章日益累加的情况下，显然是不稳妥的方案，不仅不好管理，而且每次都需要将图片手动放入到该指定目录，并在文章中指定引用的方式，很不方便。我觉得应该借鉴类似 Typora 的文件资源管理：</p>
<p><img data-src="/2023/12/13/%E8%A7%A3%E5%86%B3Hexo%E6%9C%AC%E5%9C%B0%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%BC%95%E7%94%A8%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98/Typora%E5%9B%BE%E5%83%8F.png" alt="Typora图像"></p>
<p>​    </p>
<h2 id="hexo-asset-image-插件失效原因分析"><a href="#hexo-asset-image-插件失效原因分析" class="headerlink" title="hexo-asset-image 插件失效原因分析"></a>hexo-asset-image 插件失效原因分析</h2><p>所以，Hexo 的社区便有人开发了解决此需求的第三方插件，<code>hexo-asset-image</code> 和 <code>hexo-asset-file</code></p>
<p>呼声比较高的是 <code>hexo-asset-image</code>，但经过我的检验，<code>hexo-asset-image </code> 并不能解决我的需求，因为该插件与 <code>hexo-next-theme</code> 下的图片懒加载插件 <a href="https://github.com/ApoorvSaxena/lozad.js">lozad.js</a> 冲突，这个插件会将 <code>img</code> 的 <code>src</code> 属性改为 <code>data-src</code>，而 hexo-asset-image 的工作原理是统一处理 <code>src</code> ，没有对 <code>data-src</code> 等属性的判断，所以便不会处理图片，我个人是希望能增加用户体验的，所以并不想放弃懒加载动画。想提个 PR 也已经发现原插件仓库已经被归档了。</p>
<p>​    </p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>后面采用 <a href="https://github.com/hqweay/hexo-asset-image">hexo-asset-file</a> 插件进行替代</p>
<p>该仓库的 ChangeLog：</p>
<blockquote>
<p>2019-09-23: support hexo-lazyload-image<br>2019-09-23: fixed hexo-abbrlink using *.html image path error</p>
</blockquote>
<p>我们可以发现这个插件是满足我们的预期的，对 hexo 自带的懒加载插件做了冲突解决</p>
<h3 id="Usege"><a href="#Usege" class="headerlink" title="Usege"></a>Usege</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-file --save</span><br></pre></td></tr></table></figure>

<h3 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h3><p><strong>Make sure <code>post_asset_folder: true</code> in your <code>_config.yml</code>.</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. root directory:</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://tech.panqingshan.cn</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. child directory</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://tech.panqingshan.cn/blog</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/blog/</span></span><br></pre></td></tr></table></figure>

<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new post <span class="string">&quot;文章名&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过此命令，我们可以得到一个新建md文章和对应的同级同名目录，当然你也可以选择手动创建，不过注意目录需要跟md文件名一一对应。</p>
<br>

<p>通过该插件，我们现在不仅可以在本地正常使用相对路径浏览，同时线上环境的图片地址也会有 <code>hexo-asset-file</code> 插件帮我们自动识别图片的本地相对路径并帮我们做转发，不管是在首页浏览还是进行文章详情页内，线上环境的图片都可正常显示。</p>
<p>​    </p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Hexo部署会自动删除README文件问题解决"><a href="#Hexo部署会自动删除README文件问题解决" class="headerlink" title="Hexo部署会自动删除README文件问题解决"></a>Hexo部署会自动删除README文件问题解决</h3><p>部署 Hexo 的时候发现根目录下 <code>README.md</code> 文件并没有被静态打包，Github 对应仓库缺少 README 文件介绍</p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>我们在执行命令 <code>hexo g</code> 之后，Hexo 会打包 source 目录下的文件资源，把 source 目录里的 <code>.md</code> 格式的文件渲染为 html 文件并放到 public 下，而其他目录位置则不会被打包，继续执行命令 <code>hexo d</code> 之后，Hexo 会将 public 下面的所有文件提交到对应的 <code>你的GitHub用户名.github.io</code> 仓库；</p>
<p>由于打包后本地 public 文件夹里没有 README.md 这个文件，所以在提交 public 文件时，Github 会认为你把 README.md 文件删除了，同时 Github 也会删掉仓库里的 README.md 文件，这就是具体的原因</p>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>我们可以将根目录下的 <code>README.md</code> 文件拷贝到 source目录下，并修改 Hexo 根目录下的 _config.yml 文件，将 skip_render 参数的值设置为 README.md</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">skip_render:</span> <span class="string">README.md</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span>  <span class="string">为什么需要设置这一步呢？</span></span><br><span class="line"><span class="string">//</span>  <span class="string">因为你执行hexo</span> <span class="string">g命令时，hexo</span> <span class="string">会默认将</span> <span class="string">source</span> <span class="string">文件里的所有md文件渲染为</span> <span class="string">html</span> <span class="string">文件放到</span> <span class="string">public</span> <span class="string">中，</span></span><br><span class="line"><span class="string">//</span>  <span class="string">同时</span> <span class="string">README.md</span> <span class="string">会被渲染为</span> <span class="string">README.html</span> <span class="string">文件放到</span> <span class="string">public</span> <span class="string">文件里</span></span><br><span class="line"><span class="string">//</span>  <span class="string">加上这段设置，就是告诉</span> <span class="string">hexo</span> <span class="string">的解析器，你在渲染</span> <span class="string">source</span> <span class="string">文件里的</span> <span class="string">md</span> <span class="string">文件时，跳过</span> <span class="string">README.md</span> <span class="string">文件</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h3 id="Git-Bash-手动添加到右键菜单"><a href="#Git-Bash-手动添加到右键菜单" class="headerlink" title="Git Bash 手动添加到右键菜单"></a>Git Bash 手动添加到右键菜单</h3><p>由于之前电脑重新系统，Git 重新下载过程中忘记添加注册 Git Bash 在当前目录背景打开的指令，故而重新进行手动添加，基于 <a href="https://github.com/BluePointLilac/ContextMenuManager/releases/tag/3.3.3.1">ContextMenuManager</a> 右键菜单管理工具进行，添加 bash.exe 的安装路径即可</p>
<p>​    </p>
<h3 id="Failed-to-connect-to-github-com-port-443"><a href="#Failed-to-connect-to-github-com-port-443" class="headerlink" title="Failed to connect to github.com port 443"></a>Failed to connect to github.com port 443</h3><ul>
<li><a href="https://blog.csdn.net/zpf1813763637/article/details/128340109">Git报错： Failed to connect to github.com port 443 解决方案-CSDN博客</a></li>
</ul>
<p>网络超时，使用 VPN 并配置代理（以下命令基于 <code>Clash for windows</code>，代理端口为 7890）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:7890</span><br><span class="line"></span><br><span class="line"><span class="comment">#其他命令</span></span><br><span class="line">git config --global --get http.proxy <span class="comment"># 查看代理命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理命令</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="git-config-–global-–unset-http-proxy-的作用"><a href="#git-config-–global-–unset-http-proxy-的作用" class="headerlink" title="git config –global –unset http.proxy 的作用"></a>git config –global –unset http.proxy 的作用</h4><blockquote>
<p><strong>取消代理，状态变为直连</strong></p>
</blockquote>
<p><code>git config --global --unset http.proxy</code> 这个命令用于在全局 Git 配置中取消设置 HTTP 代理。具体作用是移除全局 Git 配置中的 HTTP 代理设置，从而使 Git 在执行网络操作时不再通过指定的 HTTP 代理进行连接。</p>
<p>通常情况下，当你在使用 Git 进行网络操作（如 clone、push、pull 等）时，如果之前设置了 HTTP 代理，Git 将会通过该代理进行网络连接。但有时候代理可能会导致连接问题，或者你想要取消代理设置以直接连接网络，那么就可以使用这个命令来移除之前配置的 HTTP 代理。</p>
<p>执行 <code>git config --global --unset http.proxy</code> 命令后，Git 将不再使用之前设置的 HTTP 代理，而是直接连接网络</p>
<p>​    </p>
<h3 id="图片预览"><a href="#图片预览" class="headerlink" title="图片预览"></a>图片预览</h3><p>Hexo-next 主题内置 fancybox 预览插件，fancybox: false 为 true 就行，如果没内置 fancybox 插件，需手动下载</p>
<ul>
<li><a href="https://luhuadong.com/hexo/hexo-fancybox.html">下载参考链接</a></li>
</ul>
<p>​    </p>
<h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><ul>
<li>即使你删除了 blog 中的 .deploy_git，通过 <code>hexo s</code> 部署还是能自动生成回来的</li>
<li>博客线上环境完成部署大概有 2 分钟的滞后性，期间存在部分部署持续推进</li>
<li><a href="https://guiblogs.com/hexo30-15/">移除 Hexo 文章點擊「閱讀全文」後網址出現的 #more _</a></li>
</ul>
<p>​    </p>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a href="https://nopoetry.github.io/2020/08/03/Hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/">Hexo博客插入图片的方法</a></li>
<li><a href="https://leay.net/2019/12/25/hexo/">Hexo 引用本地图片以及引用本地任意位置图片的一点思路</a></li>
<li><a href="https://blog.csdn.net/wxl1555/article/details/79291865">hexo系列问题之部署到github时会删掉README文件</a></li>
</ul>
]]></content>
  </entry>
</search>
